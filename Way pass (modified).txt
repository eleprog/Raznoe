/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Project/Maven2/JavaApp/src/main/java/${packagePath}/${mainClassName}.java to edit this template
 */

package com.mycompany.mavenproject2;
import java.util.Scanner;

public class Mavenproject2 
{
    public static void main(String[] args)
    {
                         // 0 1 2 3 4 5		// матрица дорог
        int [][] matrix = {{0,1,0,0,0,0},  //0
                           {0,0,1,1,1,0},  //1
                           {0,0,0,0,0,1},  //2
                           {0,0,1,0,0,0},  //3
                           {0,0,0,0,0,0},  //4
                           {0,1,0,1,0,0}}; //5
        
        int [] stack = new int[100];            // создание стека
        int lowStackPointer = 0;                // указатель на нижнюю границу стека
        int highStackPointer = 0;               // указатель на верхнюю границу стека
        int stackPointer = 0;                   // указатель на последний элемент стека
        int len = matrix.length;                // длина матрицы
        boolean wayFlag = false;                // флаг наличия пути
        boolean [] flags = new boolean[len];    // массив флагов (заходили в пункт или нет)			/*=== (modified) ===*/
        
        Scanner myScnr = new Scanner(System.in);
        System.out.print("First point: ");
        stack[0] = myScnr.nextInt();            // присвоение нулевому элементу стека значение начального города 
        
        System.out.print("Second point: ");
        int secondPoint = myScnr.nextInt();     // присвоение конечного города
             
        for(int i = 0; i < len - 1 && !wayFlag; i++)        // цикл на n-1 итерацию (n - количество городов)
        {      
            for(int j = lowStackPointer; j <= highStackPointer && !wayFlag; j++)    // цикл на обработку всех необработанных элементов стека
                for(int k = 0; k < len && !wayFlag; k++)    // цикл на n итераций (для обхода строки матрицы)
                    if(matrix[stack[j]][k] > 0)             // проверка наличия пути из города в стеке в город k                        
                        if(k == secondPoint)                // если индекс города совпал с конечным городом, то путь существует
                            wayFlag = true;                 // поднятие флага наличия города
                        else if(flags[k] == false)          // если мы не были в городе k то			/*=== (modified) ===*/
                        {				    //
                            stack[++stackPointer] = k;      // заносим город k в стек
                            flags[k] = true;                // поднимаем флаг того, что мы были в городе k	/*=== (modified) ===*/
                        }
            lowStackPointer = highStackPointer + 1;         // указатель на нижнюю границу стека делаем равным верхней границе + 1
            highStackPointer = stackPointer;                // указатель на верхнюю границу стека делаем равным указателю на последний элемент стека
        }
        
        System.out.println("\nOutput: " + wayFlag);         // вывод результата программы (true - путь есть, false - пути нет)
        System.out.println("Сounter: " + stackPointer);     // вывод размера стека (для отладки)
    }
}
